from typing import Any, Callable, Literal, Optional, Tuple, Type, TypeVar, Sequence

from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gst


BASE_PARSE_FLAG_DRAINING: int = 2
BASE_PARSE_FLAG_LOST_SYNC: int = 1
BASE_TRANSFORM_SINK_NAME: str = "sink"
BASE_TRANSFORM_SRC_NAME: str = "src"
_lock = ... # FIXME Constant
_namespace: str = "GstBase"
_version: str = "1.0"

def type_find_helper(src: Gst.Pad, size: int) -> Optional[Gst.Caps]: ...
def type_find_helper_for_buffer(obj: Optional[Gst.Object], buf: Gst.Buffer) -> Tuple[Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_buffer_with_caps(obj: Optional[Gst.Object], buf: Gst.Buffer, caps: Gst.Caps) -> Tuple[Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_buffer_with_extension(obj: Optional[Gst.Object], buf: Gst.Buffer, extension: Optional[str] = None) -> Tuple[Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_data(obj: Optional[Gst.Object], data: Sequence[int]) -> Tuple[Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_data_with_caps(obj: Optional[Gst.Object], data: Sequence[int], caps: Gst.Caps) -> Tuple[Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_data_with_extension(obj: Optional[Gst.Object], data: Sequence[int], extension: Optional[str] = None) -> Tuple[Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_extension(obj: Optional[Gst.Object], extension: str) -> Optional[Gst.Caps]: ...
def type_find_helper_get_range(obj: Gst.Object, parent: Optional[Gst.Object], func: Callable[[Gst.Object, Optional[Gst.Object], int, int], Tuple[Gst.FlowReturn, Gst.Buffer]], size: int, extension: Optional[str] = None) -> Tuple[Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_get_range_full(obj: Gst.Object, parent: Optional[Gst.Object], func: Callable[[Gst.Object, Optional[Gst.Object], int, int], Tuple[Gst.FlowReturn, Gst.Buffer]], size: int, extension: Optional[str] = None) -> Tuple[Gst.FlowReturn, Gst.Caps, Gst.TypeFindProbability]: ...
def type_find_list_factories_for_caps(obj: Optional[Gst.Object], caps: Gst.Caps) -> Optional[list[Gst.TypeFindFactory]]: ...

class Adapter(GObject.Object):
    def available(self) -> int: ...
    def available_fast(self) -> int: ...
    def clear(self) -> None: ...
    def copy(self, offset: int, size: int) -> GLib.Bytes: ...
    def distance_from_discont(self) -> int: ...
    def dts_at_discont(self) -> int: ...
    def flush(self, flush: int) -> None: ...
    def get_buffer(self, nbytes: int) -> Optional[Gst.Buffer]: ...
    def get_buffer_fast(self, nbytes: int) -> Optional[Gst.Buffer]: ...
    def get_buffer_list(self, nbytes: int) -> Optional[Gst.BufferList]: ...
    def get_list(self, nbytes: int) -> Optional[list[Gst.Buffer]]: ...
    def map(self) -> Optional[bytes]: ...
    def masked_scan_uint32(self, mask: int, pattern: int, offset: int, size: int) -> int: ...
    def masked_scan_uint32_peek(self, mask: int, pattern: int, offset: int, size: int) -> Tuple[int, int]: ...
    @classmethod
    def new(cls) -> Adapter: ...
    def offset_at_discont(self) -> int: ...
    def prev_dts(self) -> Tuple[int, int]: ...
    def prev_dts_at_offset(self, offset: int) -> Tuple[int, int]: ...
    def prev_offset(self) -> Tuple[int, int]: ...
    def prev_pts(self) -> Tuple[int, int]: ...
    def prev_pts_at_offset(self, offset: int) -> Tuple[int, int]: ...
    def pts_at_discont(self) -> int: ...
    def push(self, buf: Gst.Buffer) -> None: ...
    def take(self) -> Optional[bytes]: ...
    def take_buffer(self, nbytes: int) -> Optional[Gst.Buffer]: ...
    def take_buffer_fast(self, nbytes: int) -> Optional[Gst.Buffer]: ...
    def take_buffer_list(self, nbytes: int) -> Optional[Gst.BufferList]: ...
    def take_list(self, nbytes: int) -> Optional[list[Gst.Buffer]]: ...
    def unmap(self) -> None: ...
    

class AdapterClass(GObject.GPointer): ...

class Aggregator(Gst.Element):
    class Props:
        emit_signals: bool
        latency: int
        min_upstream_latency: int
        start_time: int
        start_time_selection: AggregatorStartTimeSelection
        name: Optional[str]
        parent: Optional[Gst.Object]
    props: Props = ...
    parent: Gst.Element = ...
    srcpad: Gst.Pad = ...
    priv: AggregatorPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, emit_signals: bool = ...,
                 latency: int = ...,
                 min_upstream_latency: int = ...,
                 start_time: int = ...,
                 start_time_selection: AggregatorStartTimeSelection = ...,
                 name: Optional[str] = ...,
                 parent: Gst.Object = ...): ...
    def do_aggregate(self, timeout: bool) -> Gst.FlowReturn: ...
    def do_clip(self, aggregator_pad: AggregatorPad, buf: Gst.Buffer) -> Gst.Buffer: ...
    def do_decide_allocation(self, query: Gst.Query) -> bool: ...
    def do_finish_buffer(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_finish_buffer_list(self, bufferlist: Gst.BufferList) -> Gst.FlowReturn: ...
    def do_fixate_src_caps(self, caps: Gst.Caps) -> Gst.Caps: ...
    def do_flush(self) -> Gst.FlowReturn: ...
    def do_get_next_time(self) -> int: ...
    def do_negotiate(self) -> bool: ...
    def do_negotiated_src_caps(self, caps: Gst.Caps) -> bool: ...
    def do_peek_next_sample(self, aggregator_pad: AggregatorPad) -> Optional[Gst.Sample]: ...
    def do_propose_allocation(self, pad: AggregatorPad, decide_query: Gst.Query, query: Gst.Query) -> bool: ...
    def do_sink_event(self, aggregator_pad: AggregatorPad, event: Gst.Event) -> bool: ...
    def do_sink_event_pre_queue(self, aggregator_pad: AggregatorPad, event: Gst.Event) -> Gst.FlowReturn: ...
    def do_sink_query(self, aggregator_pad: AggregatorPad, query: Gst.Query) -> bool: ...
    def do_sink_query_pre_queue(self, aggregator_pad: AggregatorPad, query: Gst.Query) -> bool: ...
    def do_src_activate(self, mode: Gst.PadMode, active: bool) -> bool: ...
    def do_src_event(self, event: Gst.Event) -> bool: ...
    def do_src_query(self, query: Gst.Query) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def do_update_src_caps(self, caps: Gst.Caps) -> Tuple[Gst.FlowReturn, Gst.Caps]: ...
    def finish_buffer(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def finish_buffer_list(self, bufferlist: Gst.BufferList) -> Gst.FlowReturn: ...
    def get_allocator(self) -> Tuple[Gst.Allocator, Gst.AllocationParams]: ...
    def get_buffer_pool(self) -> Optional[Gst.BufferPool]: ...
    def get_force_live(self) -> bool: ...
    def get_ignore_inactive_pads(self) -> bool: ...
    def get_latency(self) -> int: ...
    def negotiate(self) -> bool: ...
    def peek_next_sample(self, pad: AggregatorPad) -> Optional[Gst.Sample]: ...
    def selected_samples(self, pts: int, dts: int, duration: int, info: Optional[Gst.Structure] = None) -> None: ...
    def set_force_live(self, force_live: bool) -> None: ...
    def set_ignore_inactive_pads(self, ignore: bool) -> None: ...
    def set_latency(self, min_latency: int, max_latency: int) -> None: ...
    def set_src_caps(self, caps: Gst.Caps) -> None: ...
    def simple_get_next_time(self) -> int: ...
    def update_segment(self, segment: Gst.Segment) -> None: ...
    

class AggregatorClass(GObject.GPointer):
    parent_class: Gst.ElementClass = ...
    flush: Callable[[Aggregator], Gst.FlowReturn] = ...
    clip: Callable[[Aggregator, AggregatorPad, Gst.Buffer], Gst.Buffer] = ...
    finish_buffer: Callable[[Aggregator, Gst.Buffer], Gst.FlowReturn] = ...
    sink_event: Callable[[Aggregator, AggregatorPad, Gst.Event], bool] = ...
    sink_query: Callable[[Aggregator, AggregatorPad, Gst.Query], bool] = ...
    src_event: Callable[[Aggregator, Gst.Event], bool] = ...
    src_query: Callable[[Aggregator, Gst.Query], bool] = ...
    src_activate: Callable[[Aggregator, Gst.PadMode, bool], bool] = ...
    aggregate: Callable[[Aggregator, bool], Gst.FlowReturn] = ...
    stop: Callable[[Aggregator], bool] = ...
    start: Callable[[Aggregator], bool] = ...
    get_next_time: Callable[[Aggregator], int] = ...
    create_new_pad: None = ...
    update_src_caps: Callable[[Aggregator, Gst.Caps], Tuple[Gst.FlowReturn, Gst.Caps]] = ...
    fixate_src_caps: Callable[[Aggregator, Gst.Caps], Gst.Caps] = ...
    negotiated_src_caps: Callable[[Aggregator, Gst.Caps], bool] = ...
    decide_allocation: Callable[[Aggregator, Gst.Query], bool] = ...
    propose_allocation: Callable[[Aggregator, AggregatorPad, Gst.Query, Gst.Query], bool] = ...
    negotiate: Callable[[Aggregator], bool] = ...
    sink_event_pre_queue: Callable[[Aggregator, AggregatorPad, Gst.Event], Gst.FlowReturn] = ...
    sink_query_pre_queue: Callable[[Aggregator, AggregatorPad, Gst.Query], bool] = ...
    finish_buffer_list: Callable[[Aggregator, Gst.BufferList], Gst.FlowReturn] = ...
    peek_next_sample: Callable[[Aggregator, AggregatorPad], Optional[Gst.Sample]] = ...
    _gst_reserved: list[None] = ...

class AggregatorPad(Gst.Pad):
    class Props:
        emit_signals: bool
        caps: Gst.Caps
        direction: Gst.PadDirection
        offset: int
        template: Gst.PadTemplate
        name: Optional[str]
        parent: Optional[Gst.Object]
    props: Props = ...
    parent: Gst.Pad = ...
    segment: Gst.Segment = ...
    priv: AggregatorPadPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, emit_signals: bool = ...,
                 direction: Gst.PadDirection = ...,
                 offset: int = ...,
                 template: Gst.PadTemplate = ...,
                 name: Optional[str] = ...,
                 parent: Gst.Object = ...): ...
    def do_flush(self, aggregator: Aggregator) -> Gst.FlowReturn: ...
    def do_skip_buffer(self, aggregator: Aggregator, buffer: Gst.Buffer) -> bool: ...
    def drop_buffer(self) -> bool: ...
    def has_buffer(self) -> bool: ...
    def is_eos(self) -> bool: ...
    def is_inactive(self) -> bool: ...
    def peek_buffer(self) -> Optional[Gst.Buffer]: ...
    def pop_buffer(self) -> Optional[Gst.Buffer]: ...
    

class AggregatorPadClass(GObject.GPointer):
    parent_class: Gst.PadClass = ...
    flush: Callable[[AggregatorPad, Aggregator], Gst.FlowReturn] = ...
    skip_buffer: Callable[[AggregatorPad, Aggregator, Gst.Buffer], bool] = ...
    _gst_reserved: list[None] = ...

class AggregatorPadPrivate(GObject.GPointer): ...

class AggregatorPrivate(GObject.GPointer): ...

class BaseParse(Gst.Element):
    class Props:
        disable_passthrough: bool
        name: Optional[str]
        parent: Optional[Gst.Object]
    props: Props = ...
    element: Gst.Element = ...
    sinkpad: Gst.Pad = ...
    srcpad: Gst.Pad = ...
    flags: int = ...
    segment: Gst.Segment = ...
    _gst_reserved: list[None] = ...
    priv: BaseParsePrivate = ...
    def __init__(self, disable_passthrough: bool = ...,
                 name: Optional[str] = ...,
                 parent: Gst.Object = ...): ...
    def add_index_entry(self, offset: int, ts: int, key: bool, force: bool) -> bool: ...
    def convert_default(self, src_format: Gst.Format, src_value: int, dest_format: Gst.Format) -> Tuple[bool, int]: ...
    def do_convert(self, src_format: Gst.Format, src_value: int, dest_format: Gst.Format, dest_value: int) -> bool: ...
    def do_detect(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_get_sink_caps(self, filter: Gst.Caps) -> Gst.Caps: ...
    def do_handle_frame(self, frame: BaseParseFrame) -> Tuple[Gst.FlowReturn, int]: ...
    def do_pre_push_frame(self, frame: BaseParseFrame) -> Gst.FlowReturn: ...
    def do_set_sink_caps(self, caps: Gst.Caps) -> bool: ...
    def do_sink_event(self, event: Gst.Event) -> bool: ...
    def do_sink_query(self, query: Gst.Query) -> bool: ...
    def do_src_event(self, event: Gst.Event) -> bool: ...
    def do_src_query(self, query: Gst.Query) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def drain(self) -> None: ...
    def finish_frame(self, frame: BaseParseFrame, size: int) -> Gst.FlowReturn: ...
    def merge_tags(self, tags: Optional[Gst.TagList], mode: Gst.TagMergeMode) -> None: ...
    def push_frame(self, frame: BaseParseFrame) -> Gst.FlowReturn: ...
    def set_average_bitrate(self, bitrate: int) -> None: ...
    def set_duration(self, fmt: Gst.Format, duration: int, interval: int) -> None: ...
    def set_frame_rate(self, fps_num: int, fps_den: int, lead_in: int, lead_out: int) -> None: ...
    def set_has_timing_info(self, has_timing: bool) -> None: ...
    def set_infer_ts(self, infer_ts: bool) -> None: ...
    def set_latency(self, min_latency: int, max_latency: int) -> None: ...
    def set_min_frame_size(self, min_size: int) -> None: ...
    def set_passthrough(self, passthrough: bool) -> None: ...
    def set_pts_interpolation(self, pts_interpolate: bool) -> None: ...
    def set_syncable(self, syncable: bool) -> None: ...
    def set_ts_at_offset(self, offset: int) -> None: ...
    

class BaseParseClass(GObject.GPointer):
    parent_class: Gst.ElementClass = ...
    start: Callable[[BaseParse], bool] = ...
    stop: Callable[[BaseParse], bool] = ...
    set_sink_caps: Callable[[BaseParse, Gst.Caps], bool] = ...
    handle_frame: Callable[[BaseParse, BaseParseFrame], Tuple[Gst.FlowReturn, int]] = ...
    pre_push_frame: Callable[[BaseParse, BaseParseFrame], Gst.FlowReturn] = ...
    convert: Callable[[BaseParse, Gst.Format, int, Gst.Format, int], bool] = ...
    sink_event: Callable[[BaseParse, Gst.Event], bool] = ...
    src_event: Callable[[BaseParse, Gst.Event], bool] = ...
    get_sink_caps: Callable[[BaseParse, Gst.Caps], Gst.Caps] = ...
    detect: Callable[[BaseParse, Gst.Buffer], Gst.FlowReturn] = ...
    sink_query: Callable[[BaseParse, Gst.Query], bool] = ...
    src_query: Callable[[BaseParse, Gst.Query], bool] = ...
    _gst_reserved: list[None] = ...

class BaseParseFrame(GObject.GBoxed):
    buffer: Gst.Buffer = ...
    out_buffer: Gst.Buffer = ...
    flags: int = ...
    offset: int = ...
    overhead: int = ...
    size: int = ...
    _gst_reserved_i: list[int] = ...
    _gst_reserved_p: list[None] = ...
    _private_flags: int = ...
    def copy(self) -> BaseParseFrame: ...
    def free(self) -> None: ...
    def init(self) -> None: ...
    @classmethod
    def new(cls, buffer: Gst.Buffer, flags: BaseParseFrameFlags, overhead: int) -> BaseParseFrame: ...
    

class BaseParsePrivate(GObject.GPointer): ...

class BaseSink(Gst.Element):
    class Props:
        async: bool
        blocksize: int
        enable_last_sample: bool
        last_sample: Optional[Gst.Sample]
        max_bitrate: int
        max_lateness: int
        processing_deadline: int
        qos: bool
        render_delay: int
        stats: Gst.Structure
        sync: bool
        throttle_time: int
        ts_offset: int
        name: Optional[str]
        parent: Optional[Gst.Object]
    props: Props = ...
    element: Gst.Element = ...
    sinkpad: Gst.Pad = ...
    pad_mode: Gst.PadMode = ...
    offset: int = ...
    can_activate_pull: bool = ...
    can_activate_push: bool = ...
    preroll_lock: GLib.Mutex = ...
    preroll_cond: GLib.Cond = ...
    eos: bool = ...
    need_preroll: bool = ...
    have_preroll: bool = ...
    playing_async: bool = ...
    have_newsegment: bool = ...
    segment: Gst.Segment = ...
    clock_id: None = ...
    sync: bool = ...
    flushing: bool = ...
    running: bool = ...
    max_lateness: int = ...
    priv: BaseSinkPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, async: bool = ...,
                 blocksize: int = ...,
                 enable_last_sample: bool = ...,
                 max_bitrate: int = ...,
                 max_lateness: int = ...,
                 processing_deadline: int = ...,
                 qos: bool = ...,
                 render_delay: int = ...,
                 sync: bool = ...,
                 throttle_time: int = ...,
                 ts_offset: int = ...,
                 name: Optional[str] = ...,
                 parent: Gst.Object = ...): ...
    def do_activate_pull(self, active: bool) -> bool: ...
    def do_event(self, event: Gst.Event) -> bool: ...
    def do_fixate(self, caps: Gst.Caps) -> Gst.Caps: ...
    def do_get_caps(self, filter: Optional[Gst.Caps] = None) -> Gst.Caps: ...
    def do_get_times(self, buffer: Gst.Buffer) -> Tuple[int, int]: ...
    def do_prepare(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_prepare_list(self, buffer_list: Gst.BufferList) -> Gst.FlowReturn: ...
    def do_preroll(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_propose_allocation(self, query: Gst.Query) -> bool: ...
    def do_render(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_render_list(self, buffer_list: Gst.BufferList) -> Gst.FlowReturn: ...
    def do_set_caps(self, caps: Gst.Caps) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def do_unlock(self) -> bool: ...
    def do_unlock_stop(self) -> bool: ...
    def do_wait_event(self, event: Gst.Event) -> Gst.FlowReturn: ...
    def get_blocksize(self) -> int: ...
    def get_drop_out_of_segment(self) -> bool: ...
    def get_last_sample(self) -> Optional[Gst.Sample]: ...
    def get_latency(self) -> int: ...
    def get_max_bitrate(self) -> int: ...
    def get_max_lateness(self) -> int: ...
    def get_processing_deadline(self) -> int: ...
    def get_render_delay(self) -> int: ...
    def get_stats(self) -> Gst.Structure: ...
    def get_sync(self) -> bool: ...
    def get_throttle_time(self) -> int: ...
    def get_ts_offset(self) -> int: ...
    def is_async_enabled(self) -> bool: ...
    def is_last_sample_enabled(self) -> bool: ...
    def is_qos_enabled(self) -> bool: ...
    def query_latency(self) -> Tuple[bool, bool, bool, int, int]: ...
    def set_async_enabled(self, enabled: bool) -> None: ...
    def set_blocksize(self, blocksize: int) -> None: ...
    def set_drop_out_of_segment(self, drop_out_of_segment: bool) -> None: ...
    def set_last_sample_enabled(self, enabled: bool) -> None: ...
    def set_max_bitrate(self, max_bitrate: int) -> None: ...
    def set_max_lateness(self, max_lateness: int) -> None: ...
    def set_processing_deadline(self, processing_deadline: int) -> None: ...
    def set_qos_enabled(self, enabled: bool) -> None: ...
    def set_render_delay(self, delay: int) -> None: ...
    def set_sync(self, sync: bool) -> None: ...
    def set_throttle_time(self, throttle: int) -> None: ...
    def set_ts_offset(self, offset: int) -> None: ...
    def wait(self, time: int) -> Tuple[Gst.FlowReturn, int]: ...
    def wait_clock(self, time: int) -> Tuple[Gst.ClockReturn, int]: ...
    def wait_preroll(self) -> Gst.FlowReturn: ...
    

class BaseSinkClass(GObject.GPointer):
    parent_class: Gst.ElementClass = ...
    get_caps: Callable[[BaseSink, Optional[Gst.Caps]], Gst.Caps] = ...
    set_caps: Callable[[BaseSink, Gst.Caps], bool] = ...
    fixate: Callable[[BaseSink, Gst.Caps], Gst.Caps] = ...
    activate_pull: Callable[[BaseSink, bool], bool] = ...
    get_times: Callable[[BaseSink, Gst.Buffer], Tuple[int, int]] = ...
    propose_allocation: Callable[[BaseSink, Gst.Query], bool] = ...
    start: Callable[[BaseSink], bool] = ...
    stop: Callable[[BaseSink], bool] = ...
    unlock: Callable[[BaseSink], bool] = ...
    unlock_stop: Callable[[BaseSink], bool] = ...
    query: Callable[[BaseSink, Gst.Query], bool] = ...
    event: Callable[[BaseSink, Gst.Event], bool] = ...
    wait_event: Callable[[BaseSink, Gst.Event], Gst.FlowReturn] = ...
    prepare: Callable[[BaseSink, Gst.Buffer], Gst.FlowReturn] = ...
    prepare_list: Callable[[BaseSink, Gst.BufferList], Gst.FlowReturn] = ...
    preroll: Callable[[BaseSink, Gst.Buffer], Gst.FlowReturn] = ...
    render: Callable[[BaseSink, Gst.Buffer], Gst.FlowReturn] = ...
    render_list: Callable[[BaseSink, Gst.BufferList], Gst.FlowReturn] = ...
    _gst_reserved: list[None] = ...

class BaseSinkPrivate(GObject.GPointer): ...

class BaseSrc(Gst.Element):
    class Props:
        blocksize: int
        do_timestamp: bool
        num_buffers: int
        typefind: bool
        name: Optional[str]
        parent: Optional[Gst.Object]
    props: Props = ...
    element: Gst.Element = ...
    srcpad: Gst.Pad = ...
    live_lock: GLib.Mutex = ...
    live_cond: GLib.Cond = ...
    is_live: bool = ...
    live_running: bool = ...
    blocksize: int = ...
    can_activate_push: bool = ...
    random_access: bool = ...
    clock_id: None = ...
    segment: Gst.Segment = ...
    need_newsegment: bool = ...
    num_buffers: int = ...
    num_buffers_left: int = ...
    typefind: bool = ...
    running: bool = ...
    pending_seek: Gst.Event = ...
    priv: BaseSrcPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, blocksize: int = ...,
                 do_timestamp: bool = ...,
                 num_buffers: int = ...,
                 typefind: bool = ...,
                 name: Optional[str] = ...,
                 parent: Gst.Object = ...): ...
    def do_alloc(self, offset: int, size: int) -> Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def do_create(self, offset: int, size: int) -> Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def do_decide_allocation(self, query: Gst.Query) -> bool: ...
    def do_do_seek(self, segment: Gst.Segment) -> bool: ...
    def do_event(self, event: Gst.Event) -> bool: ...
    def do_fill(self, offset: int, size: int, buf: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_fixate(self, caps: Gst.Caps) -> Gst.Caps: ...
    def do_get_caps(self, filter: Optional[Gst.Caps] = None) -> Gst.Caps: ...
    def do_get_size(self) -> Tuple[bool, int]: ...
    def do_get_times(self, buffer: Gst.Buffer) -> Tuple[int, int]: ...
    def do_is_seekable(self) -> bool: ...
    def do_negotiate(self) -> bool: ...
    def do_prepare_seek_segment(self, seek: Gst.Event, segment: Gst.Segment) -> bool: ...
    def do_set_caps(self, caps: Gst.Caps) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def do_unlock(self) -> bool: ...
    def do_unlock_stop(self) -> bool: ...
    def get_allocator(self) -> Tuple[Gst.Allocator, Gst.AllocationParams]: ...
    def get_blocksize(self) -> int: ...
    def get_buffer_pool(self) -> Optional[Gst.BufferPool]: ...
    def get_do_timestamp(self) -> bool: ...
    def is_async(self) -> bool: ...
    def negotiate(self) -> bool: ...
    def new_seamless_segment(self, start: int, stop: int, time: int) -> bool: ...
    def new_segment(self, segment: Gst.Segment) -> bool: ...
    def query_latency(self) -> Tuple[bool, bool, int, int]: ...
    def set_async(self, async: bool) -> None: ...
    def set_automatic_eos(self, automatic_eos: bool) -> None: ...
    def set_blocksize(self, blocksize: int) -> None: ...
    def set_caps(self, caps: Gst.Caps) -> bool: ...
    def set_do_timestamp(self, timestamp: bool) -> None: ...
    def set_dynamic_size(self, dynamic: bool) -> None: ...
    def set_format(self, format: Gst.Format) -> None: ...
    def set_live(self, live: bool) -> None: ...
    def start_complete(self, ret: Gst.FlowReturn) -> None: ...
    def start_wait(self) -> Gst.FlowReturn: ...
    def submit_buffer_list(self, buffer_list: Gst.BufferList) -> None: ...
    def wait_playing(self) -> Gst.FlowReturn: ...
    

class BaseSrcClass(GObject.GPointer):
    parent_class: Gst.ElementClass = ...
    get_caps: Callable[[BaseSrc, Optional[Gst.Caps]], Gst.Caps] = ...
    negotiate: Callable[[BaseSrc], bool] = ...
    fixate: Callable[[BaseSrc, Gst.Caps], Gst.Caps] = ...
    set_caps: Callable[[BaseSrc, Gst.Caps], bool] = ...
    decide_allocation: Callable[[BaseSrc, Gst.Query], bool] = ...
    start: Callable[[BaseSrc], bool] = ...
    stop: Callable[[BaseSrc], bool] = ...
    get_times: Callable[[BaseSrc, Gst.Buffer], Tuple[int, int]] = ...
    get_size: Callable[[BaseSrc], Tuple[bool, int]] = ...
    is_seekable: Callable[[BaseSrc], bool] = ...
    prepare_seek_segment: Callable[[BaseSrc, Gst.Event, Gst.Segment], bool] = ...
    do_seek: Callable[[BaseSrc, Gst.Segment], bool] = ...
    unlock: Callable[[BaseSrc], bool] = ...
    unlock_stop: Callable[[BaseSrc], bool] = ...
    query: Callable[[BaseSrc, Gst.Query], bool] = ...
    event: Callable[[BaseSrc, Gst.Event], bool] = ...
    create: Callable[[BaseSrc, int, int], Tuple[Gst.FlowReturn, Gst.Buffer]] = ...
    alloc: Callable[[BaseSrc, int, int], Tuple[Gst.FlowReturn, Gst.Buffer]] = ...
    fill: Callable[[BaseSrc, int, int, Gst.Buffer], Gst.FlowReturn] = ...
    _gst_reserved: list[None] = ...

class BaseSrcPrivate(GObject.GPointer): ...

class BaseTransform(Gst.Element):
    class Props:
        qos: bool
        name: Optional[str]
        parent: Optional[Gst.Object]
    props: Props = ...
    element: Gst.Element = ...
    sinkpad: Gst.Pad = ...
    srcpad: Gst.Pad = ...
    have_segment: bool = ...
    segment: Gst.Segment = ...
    queued_buf: Gst.Buffer = ...
    priv: BaseTransformPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, qos: bool = ...,
                 name: Optional[str] = ...,
                 parent: Gst.Object = ...): ...
    def do_accept_caps(self, direction: Gst.PadDirection, caps: Gst.Caps) -> bool: ...
    def do_before_transform(self, buffer: Gst.Buffer) -> None: ...
    def do_copy_metadata(self, input: Gst.Buffer, outbuf: Gst.Buffer) -> bool: ...
    def do_decide_allocation(self, query: Gst.Query) -> bool: ...
    def do_filter_meta(self, query: Gst.Query, api: Type, params: Gst.Structure) -> bool: ...
    def do_fixate_caps(self, direction: Gst.PadDirection, caps: Gst.Caps, othercaps: Gst.Caps) -> Gst.Caps: ...
    def do_generate_output(self) -> Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def do_get_unit_size(self, caps: Gst.Caps) -> Tuple[bool, int]: ...
    def do_prepare_output_buffer(self, input: Gst.Buffer) -> Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def do_propose_allocation(self, decide_query: Gst.Query, query: Gst.Query) -> bool: ...
    def do_set_caps(self, incaps: Gst.Caps, outcaps: Gst.Caps) -> bool: ...
    def do_sink_event(self, event: Gst.Event) -> bool: ...
    def do_src_event(self, event: Gst.Event) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def do_submit_input_buffer(self, is_discont: bool, input: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_transform(self, inbuf: Gst.Buffer, outbuf: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_transform_caps(self, direction: Gst.PadDirection, caps: Gst.Caps, filter: Gst.Caps) -> Gst.Caps: ...
    def do_transform_ip(self, buf: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_transform_meta(self, outbuf: Gst.Buffer, meta: Gst.Meta, inbuf: Gst.Buffer) -> bool: ...
    def do_transform_size(self, direction: Gst.PadDirection, caps: Gst.Caps, size: int, othercaps: Gst.Caps) -> Tuple[bool, int]: ...
    def get_allocator(self) -> Tuple[Gst.Allocator, Gst.AllocationParams]: ...
    def get_buffer_pool(self) -> Optional[Gst.BufferPool]: ...
    def is_in_place(self) -> bool: ...
    def is_passthrough(self) -> bool: ...
    def is_qos_enabled(self) -> bool: ...
    def reconfigure(self) -> bool: ...
    def reconfigure_sink(self) -> None: ...
    def reconfigure_src(self) -> None: ...
    def set_gap_aware(self, gap_aware: bool) -> None: ...
    def set_in_place(self, in_place: bool) -> None: ...
    def set_passthrough(self, passthrough: bool) -> None: ...
    def set_prefer_passthrough(self, prefer_passthrough: bool) -> None: ...
    def set_qos_enabled(self, enabled: bool) -> None: ...
    def update_qos(self, proportion: float, diff: int, timestamp: int) -> None: ...
    def update_src_caps(self, updated_caps: Gst.Caps) -> bool: ...
    

class BaseTransformClass(GObject.GPointer):
    parent_class: Gst.ElementClass = ...
    passthrough_on_same_caps: bool = ...
    transform_ip_on_passthrough: bool = ...
    transform_caps: Callable[[BaseTransform, Gst.PadDirection, Gst.Caps, Gst.Caps], Gst.Caps] = ...
    fixate_caps: Callable[[BaseTransform, Gst.PadDirection, Gst.Caps, Gst.Caps], Gst.Caps] = ...
    accept_caps: Callable[[BaseTransform, Gst.PadDirection, Gst.Caps], bool] = ...
    set_caps: Callable[[BaseTransform, Gst.Caps, Gst.Caps], bool] = ...
    query: Callable[[BaseTransform, Gst.PadDirection, Gst.Query], bool] = ...
    decide_allocation: Callable[[BaseTransform, Gst.Query], bool] = ...
    filter_meta: Callable[[BaseTransform, Gst.Query, Type, Gst.Structure], bool] = ...
    propose_allocation: Callable[[BaseTransform, Gst.Query, Gst.Query], bool] = ...
    transform_size: Callable[[BaseTransform, Gst.PadDirection, Gst.Caps, int, Gst.Caps], Tuple[bool, int]] = ...
    get_unit_size: Callable[[BaseTransform, Gst.Caps], Tuple[bool, int]] = ...
    start: Callable[[BaseTransform], bool] = ...
    stop: Callable[[BaseTransform], bool] = ...
    sink_event: Callable[[BaseTransform, Gst.Event], bool] = ...
    src_event: Callable[[BaseTransform, Gst.Event], bool] = ...
    prepare_output_buffer: Callable[[BaseTransform, Gst.Buffer], Tuple[Gst.FlowReturn, Gst.Buffer]] = ...
    copy_metadata: Callable[[BaseTransform, Gst.Buffer, Gst.Buffer], bool] = ...
    transform_meta: Callable[[BaseTransform, Gst.Buffer, Gst.Meta, Gst.Buffer], bool] = ...
    before_transform: Callable[[BaseTransform, Gst.Buffer], None] = ...
    transform: Callable[[BaseTransform, Gst.Buffer, Gst.Buffer], Gst.FlowReturn] = ...
    transform_ip: Callable[[BaseTransform, Gst.Buffer], Gst.FlowReturn] = ...
    submit_input_buffer: Callable[[BaseTransform, bool, Gst.Buffer], Gst.FlowReturn] = ...
    generate_output: Callable[[BaseTransform], Tuple[Gst.FlowReturn, Gst.Buffer]] = ...
    _gst_reserved: list[None] = ...

class BaseTransformPrivate(GObject.GPointer): ...

class BitReader(GObject.GPointer):
    data: bytes = ...
    size: int = ...
    byte: int = ...
    bit: int = ...
    _gst_reserved: list[None] = ...
    def free(self) -> None: ...
    def get_bits_uint16(self, nbits: int) -> Tuple[bool, int]: ...
    def get_bits_uint32(self, nbits: int) -> Tuple[bool, int]: ...
    def get_bits_uint64(self, nbits: int) -> Tuple[bool, int]: ...
    def get_bits_uint8(self, nbits: int) -> Tuple[bool, int]: ...
    def get_pos(self) -> int: ...
    def get_remaining(self) -> int: ...
    def get_size(self) -> int: ...
    def init(self, data: Sequence[int]) -> None: ...
    def peek_bits_uint16(self, nbits: int) -> Tuple[bool, int]: ...
    def peek_bits_uint32(self, nbits: int) -> Tuple[bool, int]: ...
    def peek_bits_uint64(self, nbits: int) -> Tuple[bool, int]: ...
    def peek_bits_uint8(self, nbits: int) -> Tuple[bool, int]: ...
    def set_pos(self, pos: int) -> bool: ...
    def skip(self, nbits: int) -> bool: ...
    def skip_to_byte(self) -> bool: ...
    

class BitWriter(GObject.GPointer):
    data: int = ...
    bit_size: int = ...
    bit_capacity: int = ...
    auto_grow: bool = ...
    owned: bool = ...
    _gst_reserved: list[None] = ...
    def align_bytes(self, trailing_bit: int) -> bool: ...
    def free(self) -> None: ...
    def free_and_get_buffer(self) -> Gst.Buffer: ...
    def free_and_get_data(self) -> bytes: ...
    def get_data(self) -> bytes: ...
    def get_remaining(self) -> int: ...
    def get_size(self) -> int: ...
    def put_bits_uint16(self, value: int, nbits: int) -> bool: ...
    def put_bits_uint32(self, value: int, nbits: int) -> bool: ...
    def put_bits_uint64(self, value: int, nbits: int) -> bool: ...
    def put_bits_uint8(self, value: int, nbits: int) -> bool: ...
    def put_bytes(self, data: Sequence[int], nbytes: int) -> bool: ...
    def reset(self) -> None: ...
    def reset_and_get_buffer(self) -> Gst.Buffer: ...
    def reset_and_get_data(self) -> bytes: ...
    def set_pos(self, pos: int) -> bool: ...
    

class ByteReader(GObject.GPointer):
    data: bytes = ...
    size: int = ...
    byte: int = ...
    _gst_reserved: list[None] = ...
    def dup_data(self) -> Tuple[bool, bytes]: ...
    def dup_string_utf16(self) -> Tuple[bool, list[int]]: ...
    def dup_string_utf32(self) -> Tuple[bool, list[int]]: ...
    def dup_string_utf8(self) -> Tuple[bool, list[str]]: ...
    def free(self) -> None: ...
    def get_data(self) -> Tuple[bool, bytes]: ...
    def get_float32_be(self) -> Tuple[bool, float]: ...
    def get_float32_le(self) -> Tuple[bool, float]: ...
    def get_float64_be(self) -> Tuple[bool, float]: ...
    def get_float64_le(self) -> Tuple[bool, float]: ...
    def get_int16_be(self) -> Tuple[bool, int]: ...
    def get_int16_le(self) -> Tuple[bool, int]: ...
    def get_int24_be(self) -> Tuple[bool, int]: ...
    def get_int24_le(self) -> Tuple[bool, int]: ...
    def get_int32_be(self) -> Tuple[bool, int]: ...
    def get_int32_le(self) -> Tuple[bool, int]: ...
    def get_int64_be(self) -> Tuple[bool, int]: ...
    def get_int64_le(self) -> Tuple[bool, int]: ...
    def get_int8(self) -> Tuple[bool, int]: ...
    def get_pos(self) -> int: ...
    def get_remaining(self) -> int: ...
    def get_size(self) -> int: ...
    def get_string_utf8(self) -> Tuple[bool, list[str]]: ...
    def get_uint16_be(self) -> Tuple[bool, int]: ...
    def get_uint16_le(self) -> Tuple[bool, int]: ...
    def get_uint24_be(self) -> Tuple[bool, int]: ...
    def get_uint24_le(self) -> Tuple[bool, int]: ...
    def get_uint32_be(self) -> Tuple[bool, int]: ...
    def get_uint32_le(self) -> Tuple[bool, int]: ...
    def get_uint64_be(self) -> Tuple[bool, int]: ...
    def get_uint64_le(self) -> Tuple[bool, int]: ...
    def get_uint8(self) -> Tuple[bool, int]: ...
    def init(self, data: Sequence[int]) -> None: ...
    def masked_scan_uint32(self, mask: int, pattern: int, offset: int, size: int) -> int: ...
    def masked_scan_uint32_peek(self, mask: int, pattern: int, offset: int, size: int) -> Tuple[int, int]: ...
    def peek_data(self) -> Tuple[bool, bytes]: ...
    def peek_float32_be(self) -> Tuple[bool, float]: ...
    def peek_float32_le(self) -> Tuple[bool, float]: ...
    def peek_float64_be(self) -> Tuple[bool, float]: ...
    def peek_float64_le(self) -> Tuple[bool, float]: ...
    def peek_int16_be(self) -> Tuple[bool, int]: ...
    def peek_int16_le(self) -> Tuple[bool, int]: ...
    def peek_int24_be(self) -> Tuple[bool, int]: ...
    def peek_int24_le(self) -> Tuple[bool, int]: ...
    def peek_int32_be(self) -> Tuple[bool, int]: ...
    def peek_int32_le(self) -> Tuple[bool, int]: ...
    def peek_int64_be(self) -> Tuple[bool, int]: ...
    def peek_int64_le(self) -> Tuple[bool, int]: ...
    def peek_int8(self) -> Tuple[bool, int]: ...
    def peek_string_utf8(self) -> Tuple[bool, list[str]]: ...
    def peek_uint16_be(self) -> Tuple[bool, int]: ...
    def peek_uint16_le(self) -> Tuple[bool, int]: ...
    def peek_uint24_be(self) -> Tuple[bool, int]: ...
    def peek_uint24_le(self) -> Tuple[bool, int]: ...
    def peek_uint32_be(self) -> Tuple[bool, int]: ...
    def peek_uint32_le(self) -> Tuple[bool, int]: ...
    def peek_uint64_be(self) -> Tuple[bool, int]: ...
    def peek_uint64_le(self) -> Tuple[bool, int]: ...
    def peek_uint8(self) -> Tuple[bool, int]: ...
    def set_pos(self, pos: int) -> bool: ...
    def skip(self, nbytes: int) -> bool: ...
    def skip_string_utf16(self) -> bool: ...
    def skip_string_utf32(self) -> bool: ...
    def skip_string_utf8(self) -> bool: ...
    

class ByteWriter(GObject.GPointer):
    parent: ByteReader = ...
    alloc_size: int = ...
    fixed: bool = ...
    owned: bool = ...
    _gst_reserved: list[None] = ...
    def ensure_free_space(self, size: int) -> bool: ...
    def fill(self, value: int, size: int) -> bool: ...
    def free(self) -> None: ...
    def free_and_get_buffer(self) -> Gst.Buffer: ...
    def free_and_get_data(self) -> int: ...
    def get_remaining(self) -> int: ...
    def init(self) -> None: ...
    def init_with_data(self, data: Sequence[int], initialized: bool) -> None: ...
    def init_with_size(self, size: int, fixed: bool) -> None: ...
    def put_buffer(self, buffer: Gst.Buffer, offset: int, size: int) -> bool: ...
    def put_data(self, data: Sequence[int]) -> bool: ...
    def put_float32_be(self, val: float) -> bool: ...
    def put_float32_le(self, val: float) -> bool: ...
    def put_float64_be(self, val: float) -> bool: ...
    def put_float64_le(self, val: float) -> bool: ...
    def put_int16_be(self, val: int) -> bool: ...
    def put_int16_le(self, val: int) -> bool: ...
    def put_int24_be(self, val: int) -> bool: ...
    def put_int24_le(self, val: int) -> bool: ...
    def put_int32_be(self, val: int) -> bool: ...
    def put_int32_le(self, val: int) -> bool: ...
    def put_int64_be(self, val: int) -> bool: ...
    def put_int64_le(self, val: int) -> bool: ...
    def put_int8(self, val: int) -> bool: ...
    def put_string_utf16(self, data: Sequence[int]) -> bool: ...
    def put_string_utf32(self, data: Sequence[int]) -> bool: ...
    def put_string_utf8(self, data: str) -> bool: ...
    def put_uint16_be(self, val: int) -> bool: ...
    def put_uint16_le(self, val: int) -> bool: ...
    def put_uint24_be(self, val: int) -> bool: ...
    def put_uint24_le(self, val: int) -> bool: ...
    def put_uint32_be(self, val: int) -> bool: ...
    def put_uint32_le(self, val: int) -> bool: ...
    def put_uint64_be(self, val: int) -> bool: ...
    def put_uint64_le(self, val: int) -> bool: ...
    def put_uint8(self, val: int) -> bool: ...
    def reset(self) -> None: ...
    def reset_and_get_buffer(self) -> Gst.Buffer: ...
    def reset_and_get_data(self) -> bytes: ...
    

class CollectData(GObject.GPointer):
    collect: CollectPads = ...
    pad: Gst.Pad = ...
    buffer: Gst.Buffer = ...
    pos: int = ...
    segment: Gst.Segment = ...
    state: CollectPadsStateFlags = ...
    priv: CollectDataPrivate = ...

class CollectDataPrivate(GObject.GPointer): ...

class CollectPads(Gst.Object):
    class Props:
        name: Optional[str]
        parent: Optional[Gst.Object]
    props: Props = ...
    object: Gst.Object = ...
    data: list[CollectData] = ...
    stream_lock: GLib.RecMutex = ...
    priv: CollectPadsPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(self, name: Optional[str] = ...,
                 parent: Gst.Object = ...): ...
    def add_pad(self, pad: Gst.Pad, size: int, destroy_notify: Callable[[CollectData], None], lock: bool) -> Optional[CollectData]: ...
    def available(self) -> int: ...
    def clip_running_time(self, cdata: CollectData, buf: Gst.Buffer, user_data: None) -> Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def event_default(self, data: CollectData, event: Gst.Event, discard: bool) -> bool: ...
    def flush(self, data: CollectData, size: int) -> int: ...
    @classmethod
    def new(cls) -> CollectPads: ...
    def peek(self, data: CollectData) -> Optional[Gst.Buffer]: ...
    def pop(self, data: CollectData) -> Optional[Gst.Buffer]: ...
    def query_default(self, data: CollectData, query: Gst.Query, discard: bool) -> bool: ...
    def read_buffer(self, data: CollectData, size: int) -> Optional[Gst.Buffer]: ...
    def remove_pad(self, pad: Gst.Pad) -> bool: ...
    def set_buffer_function(self, func: Callable[..., Gst.FlowReturn], *user_data: Any) -> None: ...
    def set_clip_function(self, clipfunc: Callable[..., Tuple[Gst.FlowReturn, Gst.Buffer]], *user_data: Any) -> None: ...
    def set_compare_function(self, func: Callable[..., int], *user_data: Any) -> None: ...
    def set_event_function(self, func: Callable[..., bool], *user_data: Any) -> None: ...
    def set_flush_function(self, func: Callable[..., None], *user_data: Any) -> None: ...
    def set_flushing(self, flushing: bool) -> None: ...
    def set_function(self, func: Callable[..., Gst.FlowReturn], *user_data: Any) -> None: ...
    def set_query_function(self, func: Callable[..., bool], *user_data: Any) -> None: ...
    def set_waiting(self, data: CollectData, waiting: bool) -> None: ...
    def src_event_default(self, pad: Gst.Pad, event: Gst.Event) -> bool: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def take_buffer(self, data: CollectData, size: int) -> Optional[Gst.Buffer]: ...
    

class CollectPadsClass(GObject.GPointer):
    parent_class: Gst.ObjectClass = ...
    _gst_reserved: list[None] = ...

class CollectPadsPrivate(GObject.GPointer): ...

class DataQueue(GObject.Object):
    class Props:
        current_level_bytes: int
        current_level_time: int
        current_level_visible: int
    props: Props = ...
    object: GObject.Object = ...
    priv: DataQueuePrivate = ...
    _gst_reserved: list[None] = ...
    def do_empty(self) -> None: ...
    def do_full(self) -> None: ...
    

class DataQueueClass(GObject.GPointer):
    parent_class: GObject.ObjectClass = ...
    empty: Callable[[DataQueue], None] = ...
    full: Callable[[DataQueue], None] = ...
    _gst_reserved: list[None] = ...

class DataQueuePrivate(GObject.GPointer): ...

class FlowCombiner(GObject.GBoxed):
    def add_pad(self, pad: Gst.Pad) -> None: ...
    def clear(self) -> None: ...
    def free(self) -> None: ...
    @classmethod
    def new(cls) -> FlowCombiner: ...
    def ref(self) -> FlowCombiner: ...
    def remove_pad(self, pad: Gst.Pad) -> None: ...
    def reset(self) -> None: ...
    def unref(self) -> None: ...
    def update_flow(self, fret: Gst.FlowReturn) -> Gst.FlowReturn: ...
    def update_pad_flow(self, pad: Gst.Pad, fret: Gst.FlowReturn) -> Gst.FlowReturn: ...
    

class PushSrc(BaseSrc):
    class Props:
        blocksize: int
        do_timestamp: bool
        num_buffers: int
        typefind: bool
        name: Optional[str]
        parent: Optional[Gst.Object]
    props: Props = ...
    parent: BaseSrc = ...
    _gst_reserved: list[None] = ...
    def __init__(self, blocksize: int = ...,
                 do_timestamp: bool = ...,
                 num_buffers: int = ...,
                 typefind: bool = ...,
                 name: Optional[str] = ...,
                 parent: Gst.Object = ...): ...

class PushSrcClass(GObject.GPointer):
    parent_class: BaseSrcClass = ...
    create: Callable[[PushSrc], Tuple[Gst.FlowReturn, Gst.Buffer]] = ...
    alloc: Callable[[PushSrc], Tuple[Gst.FlowReturn, Gst.Buffer]] = ...
    fill: Callable[[PushSrc, Gst.Buffer], Gst.FlowReturn] = ...
    _gst_reserved: list[None] = ...

class TypeFindData(GObject.GPointer): ...

class BaseParseFrameFlags(GObject.GFlags):
    CLIP = 4
    DROP = 8
    NEW_FRAME = 1
    NONE = 0
    NO_FRAME = 2
    QUEUE = 16

class BaseSrcFlags(GObject.GFlags):
    LAST = 1048576
    STARTED = 32768
    STARTING = 16384

class CollectPadsStateFlags(GObject.GFlags):
    EOS = 1
    FLUSHING = 2
    LOCKED = 16
    NEW_SEGMENT = 4
    WAITING = 8

class AggregatorStartTimeSelection(GObject.GEnum):
    FIRST = 1
    SET = 2
    ZERO = 0

